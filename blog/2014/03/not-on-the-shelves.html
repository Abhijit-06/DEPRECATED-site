---
layout: blog
root: ../../..
author: Greg Wilson
title: "Not on the Shelves"
date: 2014-04-23
time: "10:00:00"
category: ["Opinion"]
---
<!-- start excerpt -->
<p>
  Every few years,
  I indulge in a bit of <a href="http://en.wikipedia.org/wiki/Sympathetic_magic">sympathetic magic</a>
  by writing reviews of books that don't actually exist
  in the hope that it will inspire someone to write them.
  Previous versions written in
  <a href="http://third-bit.com/pages/not-on-the-shelves-1997.html">1997</a>,
  <a href="http://third-bit.com/pages/not-on-the-shelves-2003.html">2003</a>,
  and
  <a href="http://third-bit.com/pages/not-on-the-shelves-2009.html">2009</a>
  led (directly or indirectly) to
  <a href="http://www.amazon.com/Beautiful-Code-Leading-Programmers-Practice/dp/0596510047/"><em>Beautiful Code</em></a>,
  <a href="http://www.amazon.com/Making-Software-Really-Works-Believe/dp/0596808321/"><em>Making Software</em></a>,
  and <a href="http://aosabook.org/en/index.html"><em>The Architecture of Open Source Applications</em></a>;
  I'd welcome comments on what <em>isn't</em> out there
  that you really wish you could read.
</p>
<!-- end excerpt -->
<p><strong><em>Software Carpentry for Scientists and Engineers</em></strong></p>
<p>
  This book is an introduction to basic software development practices for graduate students and professionals
  whose background is science or engineering rather than programming.
  The four core topics&mdash;task automation, version control, structured programming, and data management&mdash;are
  are introduced via tutorials on the Unix shell, Git, Python, and SQL,
  then elaborated on with further tutorials on using the web to share data,
  creating reproducible workflows,
  and testing software when the right answer isn't actually known.
  While it necessarily glosses over many fine points,
  the book does give readers a useful toolkit
  and a sense of where to go next.
</p>
<p><strong><cite>Big, Fast, Cheap, or Good: A Student's Guide to Software Engineering</cite></strong></p>
<p>
  The
  <a href="http://www.amazon.com/Software-Engineering-A-Practitioners-Approach/dp/0078022126/">biggest</a>
  <a href="http://www.amazon.com/Software-Engineering-9th-Ian-Sommerville/dp/0137035152/">textbooks</a>
  in software engineering
  have only a tenuous relationship with the realities of either
  undergraduate student life
  or real-world software development.
  In contrast,
  this short book focuses on
  empirical results in software engineering research,
  the design and construction of actual open source applications,
  and a development process that makes sense for students
  who are tackling team development for the first time without a more experienced mentor to guide them,
  and who are required to time-slice between several courses.
</p>
<p><strong><em>A Practical Introduction to Debugging</em></strong></p>
<p>
  Most programmers spend a large part of their time debugging;
  most authors write about something else.
  <a href="http://www.amazon.com/Debugging-Indispensable-Software-Hardware-Problems/dp/0814474578/">Most</a>
  <a href="http://www.amazon.com/Debugging-Thinking-Multidisciplinary-Approach-Technologies/dp/1555583075/">books</a>
  <a href="http://www.amazon.com/Debug-It-Prevent-Pragmatic-Programmers/dp/193435628X/">on</a>
  <a href="http://www.amazon.com/The-Developers-Guide-Debugging-Edition/dp/1470185520/">the</a>
  <a href="http://www.amazon.com/The-Art-Debugging-GDB-Eclipse/dp/1593271743/">subject</a>
  are either high-level handwaving ("Make sure you're debugging the right thing")
  user's guides for particular debugging tools,
  or <a href="http://www.amazon.com/Find-Bug-Book-Incorrect-Programs/dp/0321223918/">out of date</a>.
  (The one notable exception,
  Zeller's <a href="http://www.amazon.com/Why-Programs-Fail-Second-Edition/dp/0123745152/"><em>Why Programs Fail</em></a>
  is an excellent read,
  but too advanced for most undergraduates.)
  This book fills that gap by combining an exploration of how debugging tools actually work
  with dozens of case studies showing how to apply them to real-world problems.
  And while the author only occasionally makes this explicit,
  the book also shows how to write programs that are easier to fix.
</p>
<p><strong><em>Software Tools for the World-Wide Web</em></strong></p>
<p>
  <a href="http://www.amazon.com/Software-Tools-Brian-W-Kernighan/dp/020103669X/"><em>Software Tools</em></a>
  and its sequel <a href="http://www.amazon.com/Software-Tools-Pascal-Brian-Kernighan/dp/0201103427/"><em>Software Tools in Pascal</em></a>
  were among the most influential books in the history of computing,
  as they introduced a whole generation of programmers to the Unix philosophy of tool-based computing.
  In retrospect,
  one of the reasons that philosophy succeeded was its reliance on a universal data format (strings of ASCII text)
  and communication protocol (standard input and standard output).
  This book's starting point is the now-commonplace observation that HTTP and data formats like XML and JSON have taken their place,
  and goes on to build a suite of ever-more-sophisticated tools for assembling web-based applications that use them.
  Crucially,
  the author does not shy away from the thorny issues of transactions and partial failure:
  from the midpoint onward,
  her examples all discuss the ways in which distributed applications differs from their desktop predecessors,
  and how programmers should take that into account.
</p>
<p><strong><em>Jonad in a Nutshell</em></strong></p>
<p>
  Windows <a href="http://en.wikipedia.org/wiki/Windows_PowerShell">PowerShell</a>
  (originally codenamed Monad)
  was as revolutionary in its own way as XML and HTTP:
  instead of flat text,
  PowerShell allowed tools to send one another streams of objects,
  with all the flexibility and extensibility that implies.
  This book describes Jonad,
  an open source workalike that uses Javascript as its scripting language
  instead of PowerShell's custom Perl-like syntax,
  and JSON as a default data format instead of lines of text.
</p>
<p><strong><em>Computing and the Law: A Guide for the Perplexed</em></strong></p>
<p>
  The legal aspects of the software business were complicated enough
  when the major problem was people using software without paying for it.
  This book seeks to help programmers understand the rules (or lack thereof)
  they have to live with
  by tracing the historical development of patents, copyrights, and professional responsibilities
  from the Industrial Revolution to the present day.
  Aimed squarely at people with no prior exposure to legal terminology,
  it explains concepts clearly and provides examples for each.
  Where they can,
  the authors concentrate on principles rather than particular statutes,
  as the latter are so often either non-existent or changing rapidly.
  This not only makes the book more readable,
  it also ensures that it won't quickly be outdated.
</p>
<p><strong><em>Difference Engines</em></strong></p>
<p>
  Modern version control systems do a great job of managing text,
  but are much clumsier when it comes to images, MP3s, spreadsheets, and other so-called "binary" files.
  The reason is simple:
  those formats are supported by tools for reading and writing,
  but not for differencing and merging.
  This survey describes an open source library of tools
  (the "engines" of the title)
  that can handle many widely-used formats
  from structured text like HTML to common audio and video standards.
  Readers will enjoy the combination of theory
  (such as proofs of some algorithms' performance characteristics)
  and practice
  (the design and implementation of the tools themselves).
</p>
